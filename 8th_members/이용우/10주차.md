### 멀티 쓰레드 요약
1. 각 쓰레드는 각자의 Program Counter와 Stack을 갖기 때문에
   동시에 다른 작업을 처리할 수 있다.
2. **Thread Safety**를 위해서 CPython에서는 GIL을 사용한다.
3. GIL로 인해서 CPU-Bound 작업에서는 멀티 쓰레드의 이점을 얻지 못하지만,  
   I/O-Bound 작업에서는 멀티 쓰레딩을 적극적으로 활용할 수 있다.
4. 이를 위해서 `Py_BEGIN_ALLOW_THREADS`와 `Py_END_ALLOW_THREADS`  
   매크로가 실제 구현에 사용된다. 내장 패키지 구석구석에서 해당 구현을 확인할 수 있다.
5. <font color='orange'>Thread는 프로세스와 메모리를 공유하기 때문에
   프로세스를 새로 생성하는 것 보다는 오버헤드가 적다. </font>


<br><br>

#### 코루틴
→ 실행을 중단하고 재개할 수 있는 함수, 특정 시점에서 작업을 중단하고 다른 작업을 수행할 수 있다.  
→ 호출자와 호출된 함수 사이의 제어 흐름이 상호작용  
→ 비동기 프로그래밍에서 사용  

<br>

#### 네이티브 코루틴
- 함수 앞에 `async` 키워드를 명시하여 코루틴을 반환함을 명시
- `asyncio.run()`을 통해 코루틴 객체 생성
- 실행 순서
	- 1) 새 이벤트 루프를 시작
	- 2) 코루틴 객체를 Task로 감싸기
	- 3) Task가 완료될 때 까지 실행할 CallBack을 설정
	- 4) Task가 완료될 때 까지 루프를 반복
	- 5) 결과 반환

장점
- 여러 코루틴 동시 실행 가능
- 코루틴 객체를 다른 함수의 인자로 사용 가능
	- 코루틴 객체를 서로 연결하여 연쇄적으로 처리하거나 순차적으로 생성 가능

※ 이벤트 루프
- 비동기 코드를 연결하는 접착제 역할


<br><br><hr>

### Port Scanner 예제 실행

좌: 멀티 쓰레드, 우: 멀티 쓰레드(쓰레드 수 제한)

<img src="https://github.com/wooy0ng/wooy0ng/assets/37149278/c90fcf32-f239-46e4-8b47-a6ea50958264" width=1000>